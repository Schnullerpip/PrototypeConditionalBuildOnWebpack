"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IfBlock = (function () {
    function IfBlock(startIx, endIx, elifIxs, elseIx, innerIfs) {
        if (elifIxs === void 0) { elifIxs = []; }
        if (elseIx === void 0) { elseIx = null; }
        if (innerIfs === void 0) { innerIfs = []; }
        this.startIx = startIx;
        this.endIx = endIx;
        this.elifIxs = elifIxs;
        this.elseIx = elseIx;
        this.innerIfs = innerIfs;
    }
    IfBlock.prototype.getIfRange = function () {
        var to = this.elifIxs.length > 0 ? this.elifIxs[0] : this.elseIx != null ? this.elseIx : this.endIx;
        return [this.startIx, to];
    };
    IfBlock.prototype.getElifRange = function (index) {
        if (this.elifIxs.length > index) {
            var from = this.elifIxs[index];
            var to = this.elifIxs.length > index + 1 ? this.elifIxs[index + 1] : this.elseIx != null ? this.elseIx : this.endIx;
            return [from, to];
        }
        else {
            throw "Invalid elif index '" + index + "', there are only " + this.elifIxs.length + " elifs";
        }
    };
    IfBlock.prototype.getElseRange = function () {
        if (this.elseIx != null) {
            return [this.elseIx, this.endIx];
        }
        else {
            throw 'Cannot use elseRange when elseIx is null';
        }
    };
    return IfBlock;
}());
var IfType;
(function (IfType) {
    IfType[IfType["If"] = 0] = "If";
    IfType[IfType["Elif"] = 1] = "Elif";
})(IfType || (IfType = {}));
var useTripleSlash;
function parse(source, defs, verbose, tripleSlash) {
    if (tripleSlash === undefined)
        tripleSlash = true;
    useTripleSlash = tripleSlash;
    if (source.indexOf('#if') === -1)
        return source;
    var lines = source.split('\n');
    var ifBlocks = find_if_blocks(lines);
    for (var _i = 0, ifBlocks_1 = ifBlocks; _i < ifBlocks_1.length; _i++) {
        var ifBlock = ifBlocks_1[_i];
        apply_if(lines, ifBlock, defs, verbose);
    }
    return lines.join('\n');
}
exports.parse = parse;
function find_if_blocks(lines) {
    var blocks = [];
    for (var i = 0; i < lines.length; i++) {
        if (match_if(lines[i])) {
            var ifBlock = parse_if_block(lines, i);
            blocks.push(ifBlock);
            i = ifBlock.endIx;
        }
    }
    return blocks;
}
function parse_if_block(lines, ifBlockStart) {
    var foundElifs = [];
    var foundElse = null;
    var foundEnd;
    var innerIfs = [];
    for (var i = ifBlockStart + 1; i < lines.length; i++) {
        var curLine = lines[i];
        var innerIfMatch = match_if(curLine);
        if (innerIfMatch) {
            var innerIf = parse_if_block(lines, i);
            innerIfs.push(innerIf);
            i = innerIf.endIx;
            continue;
        }
        var elifMatch = match_if(curLine, IfType.Elif);
        if (elifMatch) {
            foundElifs.push(i);
            continue;
        }
        var elseMatch = match_else(curLine);
        if (elseMatch) {
            foundElse = i;
            continue;
        }
        var endMatch = match_endif(curLine);
        if (endMatch) {
            foundEnd = i;
            break;
        }
    }
    if (foundEnd === undefined) {
        throw "#if without #endif on line " + (ifBlockStart + 1);
    }
    return new IfBlock(ifBlockStart, foundEnd, foundElifs, foundElse, innerIfs);
}
var ifRegex = function () { return useTripleSlash ? /^[\s]*\/\/\/([\s]*)#(if|elif)([\s\S]+)$/g : /^[\s]*\/\/([\s]*)#(if|elif)([\s\S]+)$/g; };
function match_if(line, type) {
    if (type === void 0) { type = IfType.If; }
    var re = ifRegex();
    var match = re.exec(line);
    return match !== null && ((type == IfType.If && match[2] == "if") || (type == IfType.Elif && match[2] == "elif"));
}
function parse_if(line) {
    var re = ifRegex();
    var match = re.exec(line);
    if (match) {
        return match[3].trim();
    }
    else {
        throw "Could not parse #if: '" + line + "'";
    }
}
function match_endif(line) {
    var re = useTripleSlash ? /^[\s]*\/\/\/([\s]*)#(endif)[\s]*$/g : /^[\s]*\/\/([\s]*)#(endif)[\s]*$/g;
    var match = re.exec(line);
    return Boolean(match);
}
function match_else(line) {
    var re = useTripleSlash ? /^[\s]*\/\/\/([\s]*)#(else)[\s]*$/g : /^[\s]*\/\/([\s]*)#(else)[\s]*$/g;
    var match = re.exec(line);
    return Boolean(match);
}
function apply_if(lines, ifBlock, defs, verbose) {
    if (verbose === void 0) { verbose = false; }
    var includeRange = null;
    var ifCond = parse_if(lines[ifBlock.startIx]);
    var ifRes = evaluate(ifCond, defs);
    var log = function (condition, outcome) {
        if (verbose) {
            console.log("#if block lines [" + (ifBlock.startIx + 1) + "-" + (ifBlock.endIx + 1) + "]: Condition '" + condition + "' is " + (outcome ? 'TRUE' : 'FALSE') + ". " + (includeRange != null ? "Including lines [" + (includeRange[0] + 1) + "-" + (includeRange[1] + 1) + "]." : 'Excluding everything.'));
        }
    };
    if (ifRes) {
        includeRange = ifBlock.getIfRange();
        log(ifCond, true);
    }
    else {
        for (var elifIx = 0; elifIx < ifBlock.elifIxs.length; elifIx++) {
            var elifLine = lines[ifBlock.elifIxs[elifIx]];
            var elifCond = parse_if(elifLine);
            var elifRes = evaluate(elifCond, defs);
            if (elifRes) {
                includeRange = ifBlock.getElifRange(elifIx);
                log(elifCond, true);
                break;
            }
        }
        if (includeRange == null) {
            if (ifBlock.elseIx != null) {
                includeRange = ifBlock.getElseRange();
            }
            log(ifCond, false);
        }
    }
    if (includeRange != null) {
        blank_code(lines, ifBlock.startIx, includeRange[0]);
        blank_code(lines, includeRange[1], ifBlock.endIx);
    }
    else {
        blank_code(lines, ifBlock.startIx, ifBlock.endIx);
    }
    for (var _i = 0, _a = ifBlock.innerIfs; _i < _a.length; _i++) {
        var innerIf = _a[_i];
        if (includeRange != null && innerIf.startIx >= includeRange[0] && innerIf.startIx <= includeRange[1]) {
            apply_if(lines, innerIf, defs, verbose);
        }
    }
}
function evaluate(condition, defs) {
    var code = "return (" + condition + ") ? true : false;";
    var args = Object.keys(defs);
    var result;
    try {
        var f = new (Function.bind.apply(Function, [void 0].concat(args, [code])))();
        result = f.apply(void 0, args.map(function (k) { return defs[k]; }));
    }
    catch (error) {
        throw "error evaluation #if condition(" + condition + "): " + error;
    }
    return result;
}
function blank_code(lines, start, end) {
    if (end === void 0) { end = start; }
    for (var t = start; t <= end; t++) {
        var len = lines[t].length;
        var lastChar = lines[t].charAt(len - 1);
        var windowsTermination = lastChar === '\r';
        if (len === 0) {
            lines[t] = '';
        }
        else if (len === 1) {
            lines[t] = windowsTermination ? '\r' : ' ';
        }
        else if (len === 2) {
            lines[t] = windowsTermination ? ' \r' : '//';
        }
        else {
            lines[t] = windowsTermination ? "/".repeat(len - 1) + '\r' : "/".repeat(len);
        }
    }
}
